msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-08-10 19:20+0000\n"
"PO-Revision-Date: 2020-08-19 09:28\n"
"Last-Translator: \n"
"Language-Team: Korean\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: ko\n"
"X-Crowdin-File: /master/docs/locale/en/LC_MESSAGES/tutorials/pulse/4_adding_measurements.po\n"
"X-Crowdin-File-ID: 9368\n"
"Language: ko_KR\n"

#: ../../tutorials/pulse/4_adding_measurements.ipynb:10
msgid "This page was generated from `tutorials/pulse/4_adding_measurements.ipynb`__."
msgstr "이 페이지는 `tutorials/pulse/4_adding_measurements.ipynb`__에서 생성되었다."

#: ../../tutorials/pulse/4_adding_measurements.ipynb:9
msgid "Adding measurements to ``Schedule``\\ s"
msgstr "``Schedule``에 측정을 추가하기"

#: ../../tutorials/pulse/4_adding_measurements.ipynb:11
msgid "Measurement is clearly a very important part of building a Pulse schedule -- this is required to get the results of our program execution! The powerful low-level control we are granted by Pulse gives us more freedom than ``QuantumCircuit``\\ s in specifying how the measurement should be done, enabling you to explore readout error mitigation. This power of course comes with responsibility: we have to understand how measurement works, and accomodate certain hardware constraints."
msgstr "측정은 명백히 펄스 스케줄을 작성하는 데 매우 중요한 부분이다 - 이것은 프로그램의 실행 결과를 얻기 위해 필요하다! 펄스가 부여한 강력한 저수준 제어는 우리에게 측정 방법을 구체화하는 데 있어서 ``QuantumCircuit` 보다 더 많은 자유를 주어 당신이 판독 에러 완화를 검토할 수 있게 해준다. 물론 이러한 권한은 책임을 동반한다: 우리는 측정이 어떻게 작동하는지 이해해야 하고 특정 하드웨어 제약조건을 수용해야 한다."

#: ../../tutorials/pulse/4_adding_measurements.ipynb:13
msgid "On this page, we will explore in depth how to create measurements, using several different approaches of increasing complexity."
msgstr "이 페이지에서는 복잡성이 증가하는 여러 가지 접근 방식을 사용하여 측정을 생성하는 방법을 심층적으로 살펴보기로 한다."

#: ../../tutorials/pulse/4_adding_measurements.ipynb:15
msgid "\\*\\*Note: Pulse allows you to receive raw, kerneled, and disciminated readout data (whereas circuits will only return discriminated data)."
msgstr "\\*\\*Note:   Pulse를 사용하면 원시, 커널 및 식별 된 판독 데이터를 수신 할 수 있다 (반면 회로는 식별 된 데이터만 반환한다)."

#: ../../tutorials/pulse/4_adding_measurements.ipynb:18
msgid "Adding a backend-default measurement with ``measure``"
msgstr "\"측정값\" 을 사용하여 백엔드 기본 측정값을 추가한다."

#: ../../tutorials/pulse/4_adding_measurements.ipynb:20
msgid "To add measurements as easily to ``Schedule``\\ s as to ``QuantumCircuit``\\ s, you just have to know which qubits you want to measure (below, qubits 0 and 1) and have a OpenPulse-enabled ``backend``:"
msgstr "``Schedule``에 ``QuantumCircuit``만큼 쉽게 측정을 추가하려면, 측정하려는 큐비트 (아래, 큐비트0 과 큐비트1) 와 OpenPulse가 활성화 된`` 백엔드 ''를 알아야한다:"

#: ../../tutorials/pulse/4_adding_measurements.ipynb:28
msgid "The ``backend`` contains a default definition for measurement, which is tailored to the qubits you are measuring."
msgstr "``backend`` 에는 측정에 대한 기본 설정들이 있으며, 측정하는 큐비트에 맞게 조정할 수 있다."

#: ../../tutorials/pulse/4_adding_measurements.ipynb:31
msgid "Basic measurement pattern and ``measure_all``"
msgstr "기본적인 측정 패턴과 ``measure_all``"

#: ../../tutorials/pulse/4_adding_measurements.ipynb:33
msgid "Let's use the default measurement feature to inspect a measurement and learn what each pulse does. Below, we use ``measure_all``, which measures all the qubits on the backend."
msgstr "기본 측정 기능을 사용하여 측정을 점검하고 각 펄스가 수행하는 작업에 대해 알아본다. 아래에서는 백엔드의 모든 큐비트를 측정하는 `measure_all``을 사용합다."

#: ../../tutorials/pulse/4_adding_measurements.ipynb:85
msgid "Each qubit has two channels related to readout, as we see above. These are the readout transmit ``MeasureChannel``\\ s, and the readout receive ``AcquireChannel``\\ s. In superconducting qubit architectures, qubits are coupled to readout resonators. The ``MeasureChannel`` and ``AcquireChannel``\\ s label signal lines which connect to the readout resonator. The coupling between the qubit and the readout resonator hybridizes their state, so when a stimulus pulse is sent to the readout resonantor, the reflected pulse is dependent on the state of the qubit. The acquisition \"pulse\" is truly a trigger specifying to the analog-to-digital converter (ADC) to begin collecting data, and for how long. That data is used to classify the qubit state."
msgstr ""

#: ../../tutorials/pulse/4_adding_measurements.ipynb:89
msgid "Specifying classical memory slots"
msgstr ""

#: ../../tutorials/pulse/4_adding_measurements.ipynb:91
msgid "If you would like to specify where your measurement results go, there is an option for that in ``measure``, called ``qubit_mem_slots``. It takes a dictionary mapping qubit indices to classical memory slots. For example, if you want to measure qubit 0 into memory slot 1, you would do this:"
msgstr ""

#: ../../tutorials/pulse/4_adding_measurements.ipynb:114
msgid "This would be equivalent to the circuit measurement ``circuit.measure(qubit_reg[0], classical_reg[1])``."
msgstr ""

#: ../../tutorials/pulse/4_adding_measurements.ipynb:126
msgid "Build a measurement sequence from pulses"
msgstr ""

#: ../../tutorials/pulse/4_adding_measurements.ipynb:128
msgid "Rather than use the default measurements provided by the backend, we can also build the measurement sequence up as a basic Pulse schedule. The example below is similar to a typical measurement on IBM systems."
msgstr ""

#: ../../tutorials/pulse/4_adding_measurements.ipynb:130
msgid "First, we'll build the measurement stimulus pulses for each of the qubits we want to measure. Below, we use a Gaussian square parametric pulse."
msgstr ""

#: ../../tutorials/pulse/4_adding_measurements.ipynb:160
msgid "Before we build the acquisition pulses, we need to understand the measurement map."
msgstr ""

#: ../../tutorials/pulse/4_adding_measurements.ipynb:163
msgid "Acquiring qubits: the measurement map ``meas_map``"
msgstr ""

#: ../../tutorials/pulse/4_adding_measurements.ipynb:165
msgid "Due to control rack hardware constraints, some qubits may need to be acquired together. This can be the case for qubits whose readout channels are multiplexed. Any OpenPulse-enabled backend will provide a ``meas_map`` to notify the user of this."
msgstr ""

#: ../../tutorials/pulse/4_adding_measurements.ipynb:167
msgid "For instance, if we see this for a 5-qubit ``backend``"
msgstr ""

#: ../../tutorials/pulse/4_adding_measurements.ipynb:175
msgid "then we know that all the qubits on this device must be acquired together. On the other hand, this output"
msgstr ""

#: ../../tutorials/pulse/4_adding_measurements.ipynb:181
msgid "tells us that qubits 0, 1 and 2 can be acquired independently, but qubits 3 and 4 must be acquired together."
msgstr ""

#: ../../tutorials/pulse/4_adding_measurements.ipynb:183
msgid "When building up a pulse schedule, be sure to add all the acquire pulses required by the backend you plan to run on. This is validated at assemble time."
msgstr ""

#: ../../tutorials/pulse/4_adding_measurements.ipynb:185
msgid "Getting back to our example, let's imagine we plan to run on a backend with this measurement map: ``[[0, 1, 2]]``. Now we can build the acquisition pulses. This is done with the ``Acquire`` command, which takes only a duration. We specify the channels and memory slots to acquire on."
msgstr ""

#: ../../tutorials/pulse/4_adding_measurements.ipynb:208
msgid "Finally, we just combine the two parts together. Every instruction is on a different channel, so appending schedules the instructions at time 0. The ``measure_schedule`` can then be added to the end of any Pulse schedule to measure qubits 0 and 1 into classical memory slots 0 and 1."
msgstr ""

#: ../../tutorials/pulse/4_adding_measurements.ipynb:240
msgid "Next, check out how to `get system information from the backends <5_gathering_system_information.ipynb>`__."
msgstr ""

